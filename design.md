###Design Write-UpFollowing the guidelines for the assignment, I created two separate classes to manage the email data items. The first class simulates an email inbox using the queue ADT. The second class simulates a sent items folder using the stack ADT. For my implementation, a third class is used for the data containing each email entered by the user.The inbox class (queue) acts as manager of my data structure, in this case a circular linked list. For setting up of the data structure, I used a struct to assemble each node and have it set the data. Since this is a circular linked list, it is only necessary to have one external pointer that tracks the end of the list.  When adding a new node, it sets the data in the node and then sets the next pointer to the beginning of the list. For each successive email that is added to the queue, a new node is created and added at the end of the queue and it�s next pointer is again set to the beginning of the list.Since the inbox is utilizing a queue system, it didn't make much sense to try and display all the items in the circular linked list. In order to demonstrate it's purpose, I decided to have the program just display the first item in the queue and then give the user the choice to either remove the item from the queue or not. That way when the user checks their inbox, it displays the first item in the queue and then provides the ability to remove that item and proceed to the next one in the queue. From a design standpoint, this makes a lot of sense. Items are added and removed from the queue on a first in - first out basis and the user is able to manage their inbox items accordingly.The sent items class (stack) acts as manager of my second data structure, in this case a flexible array.  For setting up of the data structure I used an in-struct function to assemble each node and have it create a new array of ten email items. The in-struct function also sets the next pointer to null so that I can build the linked list in a linear fashion. When a user sends an email, the data item is placed into the array in reverse order, starting at the last array position first. I designed it this way for a couple of reasons. Since the index (size of the array minus one) is decrementing after each item is added, the most recent item will always be the index value plus one. Also, once the array is full, the most recently sent item would be in the first element of the array. This made more sense to construct my arrays in this manner because the stack ADT operates by having the most recent item at the stop. My arrays work in a similar way in that the most recent item is at the �top� of the array. This turned out to be helpful when it came to displaying the items on the stack. Since the most recent item is always plus one from the index, I can display the items starting from the top and working my way to the bottom.I opted to nest my node structure for both my classes inside the private section. From a design consideration stand point, it made sense. I thought about what actually needed to have direct access to the underlying structure. Since a separate class was also managing my data, I could just let my inbox and sent classes manage the building of the nodes based upon what I wanted to pass into the private structure.For the data that contained email, I decided to create a class instead of a struct and separate it into its own .h and .cpp file.  I enjoyed the ability to segment my program into different parts. It helped me look at each section of my program more thoroughly and made it easier for debugging issues as well as providing clarity when programming. Unfortunately, using a class in this particular case does add additional code since I had to get and set the private member functions of the class in a variety of situations. Overall, it behaves very similar to a struct but it did allow me to easily organize my member functions and made the process of allocating and deallocating memory easier for me personally.As far as using a circular linked list as the data structure for my queue class, I found that while it may have been functional when organizing the data in the queue but it seemed somewhat counter intuitive to how a queue might work in the real world. A queue has a pretty definitive beginning and end. The last person in a queue is not normally within one spot of the front of the queue.  I think for a queue ADT like this a linear linked list would have worked better. The first node is the first in line and items join the queue at the end. As an item is removed from the front, the node after takes the first position and so on. Overall, the data structure worked fine but having the linked list circular takes more �work� and doesn�t provide any real benefit. In contrast, a static array would also work for a queue system but the dynamic memory benefits of using a linked list make considerably more sense because the number of items of the queue could be changing often.Using the flexible array for my data structure in my sent item class, I found that it fit the concept of a stack a bit better.  It provided the benefit of having lower memory overhead as well as the ability to quickly access individual data elements with ease. As long as the size of the array in each node was kept to a reasonable amount such as 10 or 20, then the likelihood that the allocated memory would be utilized is high and there wouldn�t be as much waste. Also, it significantly cut down on the number of traversals I would normally have to do when using a linked list. If a user only composed 10 or 20 emails than at most I would only have to move to the next node in the list to access the data. Overall, I feel like the flexible array was a good compromise for having quick access the data while still keeping the memory usage relativity low. Displaying data was as simple as running through the array in the node rather than moving from one node to the next in order to get access to a single data element.Looking at overall inefficiency, my program ultimately suffers in a couple of areas. I have mentioned the hassle of pulling information out of each data object because they are associated with a class and are private member variables. Declaring local variables just to hold information data class information is a bit redundant. Also, if I would have made my underlying data a struct, I would have been able to the setting of data with fewer function calls.If I had more time to solve the problem, I would try and clean up my code by getting rid of my data class and turning it into a struct. I also would like to experiment with exception handling so that error checking can become more centralized and easier to manage than putting in multiple checks within each function.